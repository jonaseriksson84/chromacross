---
// A hardcoded puzzle for development
const puzzle = {
	puzzleId: 1,
	words: { horizontal: "WATER", vertical: "LEMON" },
	intersection: { letter: "E", horizontalIndex: 3, verticalIndex: 1 },
	uniqueLetters: ["W", "A", "T", "E", "R", "L", "M", "O", "N"],
	colorMap: {
		W: "#4a90e2",
		A: "#7ed321",
		T: "#f5a623",
		E: "#bd10e0",
		R: "#d0021b",
		L: "#f8e71c",
		M: "#50e3c2",
		O: "#9013fe",
		N: "#b8e986",
	},
};

// The player's current state
const gameState = {
	puzzleId: 1,
	revealedLetters: [],
	incorrectGuesses: [],
	status: "IN_PROGRESS",
};

// Helper function to render the grid HTML
function renderGridHTML(puzzle, gameState) {
	const horizontal = puzzle.words.horizontal;
	const vertical = puzzle.words.vertical;
	const intersection = puzzle.intersection;

	const gridWidth = horizontal.length;
	const gridHeight = vertical.length;

	let gridHTML =
		'<div class="puzzle-grid" style="display: grid; grid-template-columns: repeat(' +
		gridWidth +
		', 1fr); gap: 2px;">';

	for (let row = 0; row < gridHeight; row++) {
		for (let col = 0; col < gridWidth; col++) {
			let letter = null;
			let isEmpty = true;

			// Check if this is part of the horizontal word
			if (row === intersection.verticalIndex) {
				letter = horizontal[col];
				isEmpty = false;
			}
			// Check if this is part of the vertical word (excluding intersection)
			else if (col === intersection.horizontalIndex) {
				letter = vertical[row];
				isEmpty = false;
			}

			if (!isEmpty && letter) {
				const color = puzzle.colorMap[letter];
				const showLetter = gameState.revealedLetters.includes(letter);
				gridHTML += `<div class="grid-cell" style="background-color: ${color}; width: 40px; height: 40px; display: flex; justify-content: center; align-items: center; border: 2px solid #4a4a4a; font-size: 1.2rem; font-weight: bold; color: #ffffff;">${showLetter ? letter : "&nbsp;"}</div>`;
			} else {
				gridHTML +=
					'<div class="grid-cell" style="background-color: transparent; border: none; width: 40px; height: 40px;"></div>';
			}
		}
	}

	gridHTML += "</div>";
	return gridHTML;
}

// Helper function to render palette HTML
function renderPaletteHTML(puzzle, gameState) {
	let paletteHTML =
		'<div style="margin-bottom: 1rem; font-weight: bold;">Color Palette</div>';
	paletteHTML +=
		'<div style="display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center;">';

	for (const [letter, color] of Object.entries(puzzle.colorMap)) {
		const displayLetter = gameState.revealedLetters.includes(letter)
			? letter
			: "?";
		paletteHTML += `
			<div style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.9rem;">
				<div style="width: 20px; height: 20px; border-radius: 50%; background-color: ${color}; border: 1px solid #666;"></div>
				= <span style="font-weight: bold; min-width: 15px;">${displayLetter}</span>
			</div>
		`;
	}

	paletteHTML += "</div>";
	return paletteHTML;
}

// Helper function to render keyboard HTML
function renderKeyboardHTML(puzzle, gameState) {
	const rows = [
		["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"],
		["A", "S", "D", "F", "G", "H", "J", "K", "L"],
		["Z", "X", "C", "V", "B", "N", "M"],
	];

	let keyboardHTML = "";

	rows.forEach((row) => {
		keyboardHTML +=
			'<div style="display: flex; justify-content: center; gap: 0.25rem; margin-bottom: 0.25rem;">';

		row.forEach((letter) => {
			let keyClass = "key";
			if (gameState.revealedLetters.includes(letter)) {
				keyClass += " correct";
			} else if (gameState.incorrectGuesses.includes(letter)) {
				keyClass += " incorrect";
			}

			keyboardHTML += `<button class="${keyClass}" data-letter="${letter}">${letter}</button>`;
		});

		keyboardHTML += "</div>";
	});

	return keyboardHTML;
}
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>ChromaCross</title>
	</head>
	<body>
		<div id="game-container">
			<header>
				<h1>ChromaCross</h1>
			</header>

			<div id="game-info">
				<div id="guess-counter">
					Remaining guesses: <span id="remaining-count">6</span>
				</div>
			</div>

			<div id="grid-container">
				<Fragment set:html={renderGridHTML(puzzle, gameState)} />
			</div>

			<div id="palette-container">
				<Fragment set:html={renderPaletteHTML(puzzle, gameState)} />
			</div>

			<div id="keyboard-container">
				<Fragment set:html={renderKeyboardHTML(puzzle, gameState)} />
			</div>

			<!-- Win/Loss Message Modals -->
			<div id="win-message" class="modal hidden">
				<div class="modal-content">
					<h2>ðŸŽ‰ Congratulations!</h2>
					<p>You solved today's ChromaCross!</p>
					<div id="win-stats"></div>
					<button id="share-button-win" class="share-button"
						>Share Results</button
					>
				</div>
			</div>

			<div id="loss-message" class="modal hidden">
				<div class="modal-content">
					<h2>ðŸ˜” Game Over</h2>
					<p>Better luck tomorrow!</p>
					<div id="loss-stats"></div>
					<button id="share-button-loss" class="share-button"
						>Share Results</button
					>
				</div>
			</div>
		</div>

		<script>
			// Game constants
			const MAX_INCORRECT_GUESSES = 6;

			// Letter to emoji mapping for share functionality
			// This creates the mapping from letters to emojis for the share text
			function createEmojiMap() {
				// Green squares for all correctly guessed letters
				const emojiMap = {};
				const allPuzzleLetters = puzzle.uniqueLetters;

				// Map each letter to green (only revealed letters will be used)
				for (let letter of allPuzzleLetters) {
					emojiMap[letter] = "ðŸŸ©"; // Green for all letters
				}

				console.log("Emoji mapping:", emojiMap);
				return emojiMap;
			}

			// Pass server-side data to client-side
			const puzzle = {
				puzzleId: 1,
				words: { horizontal: "WATER", vertical: "LEMON" },
				intersection: { letter: "E", horizontalIndex: 3, verticalIndex: 1 },
				uniqueLetters: ["W", "A", "T", "E", "R", "L", "M", "O", "N"],
				colorMap: {
					W: "#4a90e2",
					A: "#7ed321",
					T: "#f5a623",
					E: "#bd10e0",
					R: "#d0021b",
					L: "#f8e71c",
					M: "#50e3c2",
					O: "#9013fe",
					N: "#b8e986",
				},
			};

			// The player's current state (will be reactive)
			let gameState = {
				puzzleId: 1,
				revealedLetters: [],
				incorrectGuesses: [],
				status: "IN_PROGRESS",
			};

			// State persistence functions
			function saveState() {
				try {
					localStorage.setItem("chromaCrossState", JSON.stringify(gameState));
					console.log("Game state saved");
				} catch (error) {
					console.error("Failed to save game state:", error);
				}
			}

			function loadState() {
				try {
					const savedStateString = localStorage.getItem("chromaCrossState");
					if (!savedStateString) {
						console.log("No saved state found");
						return null;
					}

					const savedState = JSON.parse(savedStateString);

					// Check if the saved state matches current puzzle ID
					if (savedState.puzzleId !== puzzle.puzzleId) {
						console.log("Saved state is for a different puzzle, discarding");
						localStorage.removeItem("chromaCrossState");
						return null;
					}

					console.log("Valid saved state found, loading...");
					return savedState;
				} catch (error) {
					console.error("Failed to load game state:", error);
					// Clear corrupted data
					localStorage.removeItem("chromaCrossState");
					return null;
				}
			}

			// Add event listeners when DOM is loaded
			document.addEventListener("DOMContentLoaded", function () {
				// Load saved state before initializing
				const savedState = loadState();
				if (savedState) {
					gameState = savedState;
					console.log("Game state loaded:", gameState);
				}

				addEventListeners();
				addShareEventListeners();
				// Initial render to replace server-side content with client-side interactive version
				render();
			});

			function addEventListeners() {
				// Event delegation for keyboard clicks
				const keyboardContainer = document.getElementById("keyboard-container");
				if (keyboardContainer) {
					keyboardContainer.addEventListener("click", function (event) {
						if (event.target.classList.contains("key")) {
							const letter = event.target.dataset.letter;
							handleGuess(letter);
						}
					});
				}

				// Optional: Add physical keyboard support
				document.addEventListener("keydown", function (event) {
					const letter = event.key.toUpperCase();
					if (letter.match(/[A-Z]/)) {
						handleGuess(letter);
					}
				});
			}

			function handleGuess(letter) {
				// Check if game is over
				if (gameState.status !== "IN_PROGRESS") {
					return;
				}

				// Sanitize input
				if (!letter || !letter.match(/[A-Z]/)) {
					return;
				}

				// Check if already guessed
				if (
					gameState.revealedLetters.includes(letter) ||
					gameState.incorrectGuesses.includes(letter)
				) {
					// Provide feedback (brief shake or highlight)
					shakeElement(document.querySelector(`[data-letter="${letter}"]`));
					return;
				}

				// Check if letter is in puzzle
				if (puzzle.uniqueLetters.includes(letter)) {
					// Correct guess
					gameState.revealedLetters.push(letter);
				} else {
					// Incorrect guess
					gameState.incorrectGuesses.push(letter);
				}

				// Check win/loss conditions
				checkGameStatus();

				// Save state after every valid move
				saveState();

				// Re-render the UI
				render();
			}

			function checkGameStatus() {
				// Win condition: all unique letters have been revealed
				if (gameState.revealedLetters.length === puzzle.uniqueLetters.length) {
					gameState.status = "WON";
					console.log("Player wins!");
					return;
				}

				// Loss condition: too many incorrect guesses
				if (gameState.incorrectGuesses.length >= MAX_INCORRECT_GUESSES) {
					gameState.status = "LOST";
					console.log("Player loses!");
					return;
				}
			}

			function shakeElement(element) {
				if (element) {
					element.style.animation = "shake 0.3s";
					setTimeout(() => {
						element.style.animation = "";
					}, 300);
				}
			}

			function render() {
				renderGrid();
				renderPalette();
				renderKeyboard();
				renderGuessCounter();
				renderGameStatus();
			}

			function renderGrid() {
				const gridContainer = document.getElementById("grid-container");
				if (!gridContainer) return;

				gridContainer.innerHTML = "";

				const horizontal = puzzle.words.horizontal;
				const vertical = puzzle.words.vertical;
				const intersection = puzzle.intersection;
				const gridWidth = horizontal.length;
				const gridHeight = vertical.length;

				const grid = document.createElement("div");
				grid.className = "puzzle-grid";
				grid.style.display = "grid";
				grid.style.gridTemplateColumns = `repeat(${gridWidth}, 1fr)`;
				grid.style.gap = "2px";

				for (let row = 0; row < gridHeight; row++) {
					for (let col = 0; col < gridWidth; col++) {
						const cell = document.createElement("div");
						cell.className = "grid-cell";

						let letter = null;
						let isEmpty = true;

						if (row === intersection.verticalIndex) {
							letter = horizontal[col];
							isEmpty = false;
						} else if (col === intersection.horizontalIndex) {
							letter = vertical[row];
							isEmpty = false;
						}

						if (!isEmpty && letter) {
							cell.style.backgroundColor = puzzle.colorMap[letter];
							cell.style.width = "40px";
							cell.style.height = "40px";
							cell.style.display = "flex";
							cell.style.justifyContent = "center";
							cell.style.alignItems = "center";
							cell.style.border = "2px solid #4a4a4a";
							cell.style.fontSize = "1.2rem";
							cell.style.fontWeight = "bold";
							cell.style.color = "#ffffff";

							// Show letter if revealed or game is lost
							if (
								gameState.revealedLetters.includes(letter) ||
								gameState.status === "LOST"
							) {
								cell.textContent = letter;
							}
						} else {
							cell.style.backgroundColor = "transparent";
							cell.style.border = "none";
							cell.style.width = "40px";
							cell.style.height = "40px";
						}

						grid.appendChild(cell);
					}
				}

				gridContainer.appendChild(grid);
			}

			function renderPalette() {
				const paletteContainer = document.getElementById("palette-container");
				if (!paletteContainer) return;

				paletteContainer.innerHTML = "";

				const title = document.createElement("div");
				title.textContent = "Color Palette";
				title.style.marginBottom = "1rem";
				title.style.fontWeight = "bold";
				paletteContainer.appendChild(title);

				const paletteWrapper = document.createElement("div");
				paletteWrapper.style.display = "flex";
				paletteWrapper.style.flexWrap = "wrap";
				paletteWrapper.style.gap = "0.5rem";
				paletteWrapper.style.justifyContent = "center";

				for (const [letter, color] of Object.entries(puzzle.colorMap)) {
					const colorItem = document.createElement("div");
					colorItem.style.display = "flex";
					colorItem.style.alignItems = "center";
					colorItem.style.gap = "0.25rem";
					colorItem.style.fontSize = "0.9rem";

					const colorCircle = document.createElement("div");
					colorCircle.style.width = "20px";
					colorCircle.style.height = "20px";
					colorCircle.style.borderRadius = "50%";
					colorCircle.style.backgroundColor = color;
					colorCircle.style.border = "1px solid #666";

					const letterSpan = document.createElement("span");
					letterSpan.textContent = gameState.revealedLetters.includes(letter)
						? letter
						: "?";
					letterSpan.style.fontWeight = "bold";
					letterSpan.style.minWidth = "15px";

					colorItem.appendChild(colorCircle);
					colorItem.appendChild(document.createTextNode(" = "));
					colorItem.appendChild(letterSpan);

					paletteWrapper.appendChild(colorItem);
				}

				paletteContainer.appendChild(paletteWrapper);
			}

			function renderKeyboard() {
				const keyboardContainer = document.getElementById("keyboard-container");
				if (!keyboardContainer) return;

				keyboardContainer.innerHTML = "";

				const rows = [
					["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"],
					["A", "S", "D", "F", "G", "H", "J", "K", "L"],
					["Z", "X", "C", "V", "B", "N", "M"],
				];

				rows.forEach((row) => {
					const rowDiv = document.createElement("div");
					rowDiv.style.display = "flex";
					rowDiv.style.justifyContent = "center";
					rowDiv.style.gap = "0.25rem";
					rowDiv.style.marginBottom = "0.25rem";

					row.forEach((letter) => {
						const key = document.createElement("button");
						key.className = "key";
						key.textContent = letter;
						key.dataset.letter = letter;

						// Set key state based on game state
						if (gameState.revealedLetters.includes(letter)) {
							key.classList.add("correct");
							console.log(`Key ${letter} marked as correct`);
						} else if (gameState.incorrectGuesses.includes(letter)) {
							key.classList.add("incorrect");
							console.log(`Key ${letter} marked as incorrect`);
						}

						// Apply styles directly to ensure visibility
						key.style.backgroundColor = "#3a3a3a";
						key.style.border = "2px solid #4a4a4a";
						key.style.borderRadius = "4px";
						key.style.padding = "0.75rem";
						key.style.fontSize = "1rem";
						key.style.fontWeight = "bold";
						key.style.color = "#ffffff";
						key.style.cursor = "pointer";
						key.style.transition = "all 0.2s ease";
						key.style.minWidth = "40px";

						if (gameState.revealedLetters.includes(letter)) {
							key.style.backgroundColor = "#4caf50";
							key.style.borderColor = "#66bb6a";
						} else if (gameState.incorrectGuesses.includes(letter)) {
							key.style.backgroundColor = "#616161";
							key.style.borderColor = "#757575";
							key.style.color = "#bdbdbd";
						}

						rowDiv.appendChild(key);
					});

					keyboardContainer.appendChild(rowDiv);
				});
			}

			function renderGuessCounter() {
				const remainingCountElement =
					document.getElementById("remaining-count");
				if (!remainingCountElement) return;

				const remaining =
					MAX_INCORRECT_GUESSES - gameState.incorrectGuesses.length;
				remainingCountElement.textContent = remaining;

				// Add warning styling when getting low
				remainingCountElement.classList.remove("warning");
				if (remaining <= 2 && remaining > 0) {
					remainingCountElement.classList.add("warning");
				}

				// Hide the counter when game is over
				const guessCounter = document.getElementById("guess-counter");
				if (gameState.status !== "IN_PROGRESS") {
					guessCounter.style.display = "none";
				} else {
					guessCounter.style.display = "inline-block";
				}
			}

			function renderGameStatus() {
				const winModal = document.getElementById("win-message");
				const lossModal = document.getElementById("loss-message");

				// Hide both modals by default
				winModal.classList.add("hidden");
				lossModal.classList.add("hidden");

				if (gameState.status === "WON") {
					// Show win modal
					winModal.classList.remove("hidden");

					// Update win stats
					const winStats = document.getElementById("win-stats");
					const totalGuesses =
						gameState.revealedLetters.length +
						gameState.incorrectGuesses.length;
					const incorrectCount = gameState.incorrectGuesses.length;

					winStats.innerHTML = `
						<p><strong>Solved in ${totalGuesses} guesses!</strong></p>
						<p>${incorrectCount} incorrect guess${incorrectCount !== 1 ? "es" : ""}</p>
					`;
				} else if (gameState.status === "LOST") {
					// Show loss modal
					lossModal.classList.remove("hidden");

					// Update loss stats
					const lossStats = document.getElementById("loss-stats");
					const totalGuesses =
						gameState.revealedLetters.length +
						gameState.incorrectGuesses.length;
					const correctCount = gameState.revealedLetters.length;

					lossStats.innerHTML = `
						<p><strong>You made ${totalGuesses} guesses</strong></p>
						<p>${correctCount} correct, ${MAX_INCORRECT_GUESSES} incorrect</p>
						<p><strong>The words were: ${puzzle.words.horizontal} / ${puzzle.words.vertical}</strong></p>
					`;
				}
			}

			function addShareEventListeners() {
				const shareButtonWin = document.getElementById("share-button-win");
				const shareButtonLoss = document.getElementById("share-button-loss");

				if (shareButtonWin) {
					shareButtonWin.addEventListener("click", handleShare);
				}
				if (shareButtonLoss) {
					shareButtonLoss.addEventListener("click", handleShare);
				}
			}

			async function handleShare(event) {
				const button = event.target;
				const shareText = generateShareText();

				try {
					await navigator.clipboard.writeText(shareText);

					// Provide user feedback
					const originalText = button.textContent;
					button.textContent = "Copied!";
					button.classList.add("copied");

					setTimeout(() => {
						button.textContent = originalText;
						button.classList.remove("copied");
					}, 2000);
				} catch (error) {
					console.error("Failed to copy to clipboard:", error);
					// Fallback: show the text in an alert or prompt
					prompt("Copy this text to share your results:", shareText);
				}
			}

			function generateShareText() {
				const title = `ChromaCross #${puzzle.puzzleId}`;
				const yellowSquare = "ðŸŸ¨"; // Emoji for unguessed letters on loss
				let summary = "";
				let gridText = "";

				const emojiMap = createEmojiMap();
				const horizontalWord = puzzle.words.horizontal;
				const verticalWord = puzzle.words.vertical;
				const hIndex = puzzle.intersection.horizontalIndex;
				const vIndex = puzzle.intersection.verticalIndex;

				// Helper function to avoid repeating grid construction logic
				function buildGrid(getEmojiForLetter) {
					let text = "";
					const emptyCell = "â¬›"; // Use black square for empty cells
					const gridWidth = horizontalWord.length;
					const gridHeight = verticalWord.length;

					// Build full grid row by row
					for (let row = 0; row < gridHeight; row++) {
						for (let col = 0; col < gridWidth; col++) {
							let letter = null;
							let isEmpty = true;

							// Check if this cell is part of the horizontal word
							if (row === vIndex) {
								letter = horizontalWord[col];
								text += getEmojiForLetter(letter);
							}
							// Check if this cell is part of the vertical word
							else if (col === hIndex) {
								letter = verticalWord[row];
								text += getEmojiForLetter(letter);
							}
							// Empty cell
							else {
								text += emptyCell;
							}
						}
						text += "\n";
					}

					return text.trim();
				}

				// --- Main Logic Branch ---
				if (gameState.status === "WON") {
					const attempts =
						gameState.revealedLetters.length +
						gameState.incorrectGuesses.length;
					summary = `Solved in ${attempts} guesses (${gameState.incorrectGuesses.length} incorrect)`;

					// Build the grid with all colors
					gridText = buildGrid((letter) => emojiMap[letter]);
				} else if (gameState.status === "LOST") {
					summary = `Found ${gameState.revealedLetters.length}/${puzzle.uniqueLetters.length} letters`;
					const revealed = gameState.revealedLetters;

					// Build the grid, checking if each letter was revealed
					gridText = buildGrid((letter) =>
						revealed.includes(letter) ? emojiMap[letter] : yellowSquare,
					);
				}

				return `${title}\n${summary}\n${gridText}\n#ChromaCross`;
			}
		</script>
	</body>
</html>

<style>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
	}

	body {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
			Ubuntu, Cantarell, sans-serif;
		background-color: #1a1a1a;
		color: #ffffff;
		min-height: 100vh;
		display: flex;
		justify-content: center;
		align-items: center;
		padding: 20px;
	}

	#game-container {
		max-width: 500px;
		width: 100%;
		display: flex;
		flex-direction: column;
		gap: 2rem;
		text-align: center;
	}

	header h1 {
		font-size: 2.5rem;
		font-weight: bold;
		margin-bottom: 1rem;
		background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	#game-info {
		text-align: center;
		margin-bottom: 1rem;
		font-size: 1.1rem;
	}

	#guess-counter {
		background-color: #2a2a2a;
		border: 2px solid #3a3a3a;
		border-radius: 8px;
		padding: 0.75rem 1rem;
		display: inline-block;
	}

	#remaining-count {
		font-weight: bold;
		color: #4ecdc4;
	}

	#remaining-count.warning {
		color: #ff6b6b;
	}

	#grid-container {
		background-color: #2a2a2a;
		border-radius: 8px;
		padding: 1.5rem;
		min-height: 200px;
		display: flex;
		justify-content: center;
		align-items: center;
		border: 2px solid #3a3a3a;
	}

	.grid-cell {
		width: 40px;
		height: 40px;
		border: 2px solid #4a4a4a;
		display: flex;
		justify-content: center;
		align-items: center;
		font-size: 1.2rem;
		font-weight: bold;
		background-color: #3a3a3a;
	}

	#palette-container {
		background-color: #2a2a2a;
		border-radius: 8px;
		padding: 1.5rem;
		min-height: 100px;
		border: 2px solid #3a3a3a;
		display: flex;
		justify-content: center;
		align-items: center;
		flex-wrap: wrap;
		gap: 0.5rem;
	}

	#keyboard-container {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.key {
		background-color: #3a3a3a;
		border: 2px solid #4a4a4a;
		border-radius: 4px;
		padding: 0.75rem;
		font-size: 1rem;
		font-weight: bold;
		color: #ffffff;
		cursor: pointer;
		transition: all 0.2s ease;
		min-width: 40px;
		display: flex;
		justify-content: center;
		align-items: center;
	}

	.key:hover {
		background-color: #4a4a4a;
		transform: scale(1.05);
	}

	.key.correct {
		background-color: #4caf50;
		border-color: #66bb6a;
	}

	.key.incorrect {
		background-color: #616161;
		border-color: #757575;
		color: #bdbdbd;
	}

	.modal {
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		background-color: rgba(0, 0, 0, 0.8);
		display: flex;
		justify-content: center;
		align-items: center;
		z-index: 1000;
	}

	.modal.hidden {
		display: none;
	}

	.modal-content {
		background-color: #2a2a2a;
		border-radius: 12px;
		padding: 2rem;
		max-width: 400px;
		width: 90%;
		text-align: center;
		border: 2px solid #4a4a4a;
	}

	.modal-content h2 {
		margin-bottom: 1rem;
		font-size: 1.5rem;
	}

	.modal-content p {
		margin-bottom: 1rem;
		line-height: 1.5;
	}

	.share-button {
		background-color: #4ecdc4;
		border: none;
		border-radius: 8px;
		padding: 0.75rem 1.5rem;
		font-size: 1rem;
		font-weight: bold;
		color: #1a1a1a;
		cursor: pointer;
		transition: all 0.2s ease;
		margin-top: 1rem;
	}

	.share-button:hover {
		background-color: #45b7d1;
		transform: scale(1.05);
	}

	.share-button:active {
		transform: scale(0.95);
	}

	.share-button.copied {
		background-color: #4caf50;
	}

	@keyframes shake {
		0%,
		100% {
			transform: translateX(0);
		}
		25% {
			transform: translateX(-5px);
		}
		75% {
			transform: translateX(5px);
		}
	}

	@media (max-width: 600px) {
		#game-container {
			max-width: 100%;
			gap: 1.5rem;
		}

		header h1 {
			font-size: 2rem;
		}

		.grid-cell {
			width: 35px;
			height: 35px;
			font-size: 1rem;
		}

		.key {
			padding: 0.5rem;
			font-size: 0.9rem;
		}
	}
</style>
